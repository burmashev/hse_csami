<html><head><meta charset="utf-8"/></head>
<body>
<table border="1"><tr><td><b>Time limit:</b></td><td><tt>3 s</tt></td></tr>
<tr><td><b>Real time limit:</b></td><td><tt>4 s</tt></td></tr>
<tr><td><b>Memory limit:</b></td><td><tt>64M</tt></td></tr>
</table>
<h3>Problem kr08-3: kr8/blocks_hashing</h3>
<p>Напишите программу <code>./blockwise_hash seed msg_len block_size</code>,
        которая генерирует msg_len байт случайных данных, и каждые block_size байт хеширует.
        seed, msg_len, block_size - целые числа, записанные в десятичном виде.
        Для генерации случайных данных используйте функцию <code>(char)rand()</code> стандартной
        библиотеки Си с приведением к типу char. Для задания seed генератора псевдослучайных чисел
        используйте функцию <code>srand(seed)</code> стандартной библиотеки Си с
        предоставленным значением seed. Обратите внимание, что
        данные должны генерироваться последовательно.</p>
<p>Для хеширования данных используйте функцию
        <code>void some_hash(char* data, size_t n, char* out) </code>, где
        data - массив данных, от которых вы хотите взять хеш, n - размер этого массива,
        out - указатель на массив выходных данных. Функция some_hash предоставляется извне.
        Количество памяти, необходимое указателю char* out, вы должны получить из функции
        <code>size_t get_hash_size()</code> Гарантируется, что char* out
        после вызова функции some_hash - null-terminated строка.</p>
<p>Программа должна для каждого отдельного блока вывести строку
        <code>[block_no]\thash(block)\n</code>, где
        block_number - номер блока,
        hash - значение хэш-функции от этого блока.
        Нумерация блоков начинается с единицы.</p>
<p>Обратите внимание, что msg_len может быть слишком большим для того, чтобы
        хранить его в памяти полностью.</p>
<p>Обратите внимание, что порядок вывода хешей должен совпадать с порядком блоков данных.
        Т.е. нельзя вывести сначала хеш от блока с номером 2, а потом хеш от блока с номером 1.</p>
<p>Обратите внимание, что последний блок в сообщении может быть меньше, чем block_size
        (т.е. msg_len не кратен block_size). В таком случае нужно взять хеш только от реального размера
        блока.</p>
<p>Гарантируется, что памяти процесса достаточно для выделения 4 * block_size байт (и даже немного больше).
        Гарантируется, что дополнительных 4 потоков достаточно для решения задачи.</p>
<h3>Examples</h3><h4>Input</h4>
<pre>./blockwise_hash 42 4100 2048</pre>
<h4>Output</h4>
<pre>[1]\tthis_block_is_good
[2]\tthis_block_is_bad
[3]\tthis_block_is_ugly
</pre>
</body></html>