<html><head><meta charset="utf-8"/></head>
<body>
<table border="1"><tr><td><b>Time limit:</b></td><td><tt>2 s</tt></td></tr>
<tr><td><b>Real time limit:</b></td><td><tt>5 s</tt></td></tr>
<tr><td><b>Memory limit:</b></td><td><tt>64M</tt></td></tr>
</table>
<h3>Problem kr03-5: kr3/float2fp16</h3>
<p>В этой задаче мы будем работать с 16-битным представлением вещественных чисел, известным как FP16 или
            half precision — <a href="https://ru.wikipedia.org/wiki/Число_половинной_точности">число половинной точности</a>.
            В таком представлении 1 бит знака, 5 бит экспоненты (которая хранится с bias 15) и 10 бит дробной части мантиссы.
            Хранить такие числа мы будем в переменных типа uint16_t.</p>
<p>Напишите функцию <code>uint16_t float_to_fp16(float f)</code>, которая преобразует 32-битное вещественное число
            в 16-битное. Гарантируется, что значение f не является денормализованным ни в 32-битном, ни в 16-битном представлении
            (обрабатывать денормализованные числа не нужно).</p>
<p>Дробная часть округляется к ближайшему чётному. Знак аргумента сохраняется.
            Бесконечности переходят в бесконечности, NaNы в NaNы.
            При переполнении экспоненты должна получиться бесконечность.
            При преобразовании любого NaN должна
            получаться дробная часть 0b00’0000’0001 (одна единица в младшем разряде).</p>
<p>Например, число 1.0 в FP16 будет представлено как 0x3c00, так что <code>float_to_fp16(1.0) == 0x3c00</code>.</p>
</body></html>