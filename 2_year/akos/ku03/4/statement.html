<html><head><meta charset="utf-8"/></head>
<body>
<table border="1"><tr><td><b>Time limit:</b></td><td><tt>1 s</tt></td></tr>
<tr><td><b>Real time limit:</b></td><td><tt>5 s</tt></td></tr>
<tr><td><b>Memory limit:</b></td><td><tt>64M</tt></td></tr>
</table>
<h3>Problem ku03-4: kr03-4 (дореш)</h3>
<p>В этой задаче мы будем работать с 16-битным представлением вещественных чисел, известным как FP16 или
            half precision — <a href="https://ru.wikipedia.org/wiki/Число_половинной_точности">число половинной точности</a>.
            В таком представлении 1 бит знака, 5 бит экспоненты (которая хранится с bias 15) и 10 бит дробной части мантиссы.
            Хранить такие числа мы будем в переменных типа uint16_t.</p>
<p>Напишите функцию <code>uint16_t sat_mul4_half(uint16_t f)</code>, которая принимает 16-битное вещественное число
            и возвращает:</p>
<ul>
<li>свой аргумент, если он бесконечность или NaN;</li>
<li><code>4*f</code>, если это число представимо в FP16;</li>
<li>максимальное по модулю конечное представимое число того же знака, что f, в остальных случаях.</li>
</ul>
<p>Например, число 1.0 в FP16 будет представлено как 0x3c00 (биты экспоненты 01111, биты дробной части нулевые),
                а число 4.0 как 0x4400 (биты экспоненты 10001, биты дробной части нулевые),
                так что <code>sat_mul4_half(0x3c00) == 0x4400</code>.</p>
</body></html>