|                      |       |
|----------------------|-------|
| **Time limit:**      | `1 s` |
| **Real time limit:** | `5 s` |
| **Memory limit:**    | `64M` |


### Problem kr07-4: kr7/manyfiles_hash

Напишите функцию `void fd_watcher(const struct file_t* files, size_t n) `, которая слушает указанные
дескрипторы на чтение и на каждые 2048 байт выводит результат функции `void some_hash(char* data,
size_t n, char* out) ` на стандартный вывод. Функция some_hash предоставляется извне. Указатель
`char* out` должен быть предоставлен вами. Количество памяти, необходимое указателю, вы должны
получить из функции `size_t get_hash_size()`.

Структура file_t определена так:

    
    
    struct file_t {
        int fd;
        char* filename;
    };

Программа должна для каждого отдельного блока вывести строку
`[{filename}]\t[{block_number}]\t{hash}`, где filename - имя файла, к которому относится блок,
block_number - номер блока в файле, hash - значение хэш-функции от этого блока.

Вы не должны завершать прослушивание после того, как получили EOF. Функция должна работать до тех
пор, пока не получит сигнал на завершение. Особым образом сигнал обрабатывать не надо, закрывать
дескрипторы тоже.

Гарантируется, что все дескрипторы валидные, а имена файлов - null-terminated строки. Гарантируется,
что количество полученных из дескрипторов байтов кратно 2048. Гарантируется, что file_t.filename -
null-terminated строка. Гарантируется, что char* out после вызова функции some_hash - null-
terminated строка.

### Examples

#### Input

    
    
    fd_watcher({ {3, "some_file.bin"} }, 1);

#### Output

    
    
    [some_file.bin]\t[1]\tthis_block_is_even
    [some_file.bin]\t[1]\tthis_block_is_odd
    

